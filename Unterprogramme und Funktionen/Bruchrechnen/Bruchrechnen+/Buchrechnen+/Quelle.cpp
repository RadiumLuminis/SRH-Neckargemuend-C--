//Aufgabe zum Thema Bruchrechnen vom 05.02.2021
//Sven Krusch

#include <math.h>
#include <iostream>
using namespace std;

//Prototyping der (Unter-) Funktionen
double addieren(int, int, int, int);
double subtrahieren(int, int, int, int);
double multiplizieren(int, int, int, int);
double dividieren(int, int, int, int);
void Kuerzen(int [], int, int, int);
void UnechterBruch(int, int);

void main()																								//Hier wird das Hauptprogramm aufgerufen
{
	//Erstellen einer Primzahlenliste bis 100 -------------------------------------------------------------------------------------------------------------------

	int prime[100];										//Arrays aus Primzahlen
	prime[0] = 2;										//Erste Primzahl
	int Laenge = 1;										//Länge des Arrays

	int x, i;
	for (x = 2; x <= 100; x++)
	{
		for (i = 2; i <= (int) sqrt(x); i++)
		{
			if (x % i == 0 && x != i)
			{
				break;
			}

			if (i == x)
			{
				prime[Laenge] = x;
				Laenge++;
			}
		}
	}

	//-----------------------------------------------------------------------------------------------------------------------------------------------------------

	int z1, z2, n1, n2;																						//Anlegen der Variablen für die Zähler und Nenner
	char p;																									//Anlegen einer Variable als Platzhalter

	cout << "Ersten Bruch eingeben: (zaehler/nenner)" << endl; cin >> z1 >> p >> n1;						//Variablen werden eingegeben
	cout << "Zweiten Bruch eingeben: (zaehler/nenner)" << endl; cin >> z2 >> p >> n2;


	//----Switch-Case vom 19.02 ----------------------------------------------------------------------------------------------------------------------------------

	while (p != '1')																							//Schleife, die aufhört, wenn "p" auf '1' steht
	{
		cout << "Addieren, Subtrahieren, Multiplizieren oder Dupliziern? (+, -, *, /)" << endl; cin >> p;		//Eingabe, welche Rechenoperation durchgeführt werden soll
		

		switch (p)																								//Switch Abfrage, die die Variable "p" testet
		{
		case'+':																								//Wenn "p" den Wert	'+' hat:
			cout << "Die Summe der Brueche lautet: " << addieren(z1, z2, n1, n2) << endl << endl;					//Gib die Summe aus
			Kuerzen(prime, Laenge, (z1 * n2) + (z2 * n1), n1 * n2);													//Kürzt den Bruch
			p = '1';																								//Setzt p aus 1 (Um Schleife zu beenden)
			break;																									//Beendet die Switch-Abfrage
				
		case'-':																								//Wenn "p" den Wert	'-' hat:
			cout << "Die Differenz der Brueche lautet: " << subtrahieren(z1, z2, n1, n2) << endl << endl;			//Gibt die Differenz aus
			Kuerzen(prime, Laenge, (z1 * n2) + (z2 * n1), n1 * n2);													//Kürzt den Bruch
			p = '1';																								//Setzt p aus 1 (Um Schleife zu beenden)
			break;																									//Beendet die Switch-Abfrage

		case'*':																								//Wenn "p" den Wert	'*' hat:
			cout << "Das Produkt der Brueche lautet: " << multiplizieren(z1, z2, n1, n2) << endl << endl;			//Gibt das Produkt aus
			Kuerzen(prime, Laenge, (z1 * n2) + (z2 * n1), n1 * n2);													//Kürzt den Bruch
			p = '1';																								//Setzt p aus 1 (Um Schleife zu beenden)
			break;																									//Beendet die Switch-Abfrage

		case'/':																								//Wenn "p" den Wert '/' hat:
			cout << "Der Quotient der Brueche lautet: " << dividieren(z1, z2, n1, n2) << endl << endl;				//Gibt den Quotienten aus
			Kuerzen(prime, Laenge, (z1 * n2) + (z2 * n1), n1 * n2);													//Kürzt den Bruch
			p = '1';																								//Setzt p aus 1 (Um Schleife zu beenden)
			break;																									//Beendet die Switch-Abfrage

		default:																								//Wenn "p" einen anderen Wert hat:
			cout << "Ungültige Eingabe!" << endl;																	//Gibt "Ungültige Eingabe!" aus und wiederholt die Schleife (p ist nicht '1')
		}

	}

	system("pause");
}

double addieren(int z1, int z2, int n1, int n2)															//Unterfunktion addieren() mit Zählern und Nennern als Übergabeparameter ---------------------
{
	if (n1 != n2)																							//Prüft, ob die Nenner gleich sind
	{
		z1 *= n2;																								//Wenn ungleich, wird Zähler mit Nenner multiplziert, um auf gleichen Nenner zu kommen
		z2 *= n1;
		n1 *= n2;
	}

	int sum = z1 + z2;																						//Legt Variable mit Summer der Zähler an (Sprich Addiert die Brüche)
	double ausgabe = (double) sum / (double) n1;															//Dividiert Zähler durch Nenner															

	return ausgabe;																							//Gibt das Ergebnis als Wert zurück
}

double subtrahieren(int z1, int z2, int n1, int n2)														//Unterfunktion subtrahieren() mit Zählern und Nennern als Übergabeparameter -----------------
{
	if (n1 != n2)																							//Prüft, ob die Nenner gleich sind
	{
		z1 *= n2;																								//Wenn ungleich, wird Zähler mit Nenner multiplziert, um auf gleichen Nenner zu kommen
		z2 *= n1;
		n1 *= n2;
	}

	int dif = z1 - z2;																						//Legt Variable mit Differenz der beiden Zähler an (Subtrahiert die Brüche)
	double ausgabe = (double) dif / (double) n1;															//Dividiert Zähler durch Nenner			

	return ausgabe;																							//Gibt das Ergebnis als Wert zurück
}

double multiplizieren(int z1, int z2, int n1, int n2)													//Unterfunktion multiplizieren() mit Zählern und Nennern als Übergabeparameter ---------------
{
	int z = z1 * z2;																						//Legt Variable für Zähler mit Produkt der beiden Zähler an
	int n = n1 * n2;																						//Legt Variable für Nenner aus Produkt der beiden Nenner an
																												//(Kommentar am Rande: So funktioniert Multiplizieren bei Brüchen)

	double ausgabe = (double) z / (double) n;																//Dividiert Zähler durch Nenner

	return ausgabe;																							//Gibt das Ergebnis als Wert zurück
}

double dividieren(int z1, int z2, int n1, int n2)														//Unterfunktion dividieren() mit Zählern und Nennern als Übergabeparameter -------------------
{
	int z = z1 * n2;																						//Legt Variable für Zähler an. Ist gleich Erster Zähler mal zweiter Nenner
	int n = n1 * z2;																						//Legt Variable für Nenner an, entspricht dem ersten Nenner mal den zweiter Zähler
																													//(Kommentar am Rande: So funktioniert Dividierern bei Brüchen)


	double ausgabe = (double) z / (double) n;																//Dividiert Zähler durch Nenner

	return ausgabe;																							//Gibt das Ergebnis als Wert zurück
}

//Zusatzaufgabe 12.02 - Kuerzen und Unechte Brüche ---------------------------------------------------------------------------------------------------------------------------------------------------

void Kuerzen(int prime[], int Laenge, int z, int n)														//Unterfunktion Kuerzen mit Primzahlenliste, Länge dieser sowie Zähler und Nenner als Parameter
{
	for (int i = 0; i < Laenge; i++)																	//Schleife, die über die Primzahlenliste drüber läuft														
	{
		if (z % prime[i] == 0 && n % prime[i] == 0)														//Prüft, ob Zähler und Nenner durch die Primzahl teilbar sind
		{
			z /= prime[i];																				//Wenn dem so ist, werden beide dadurch geteilt
			n /= prime[i];																				
			i--;																						//Eine Zahl kann mehrmals durch Primzahlen geteilt werden, daher wird der Zählwert bei
		}																								//erfolgreichem Teilvorgang um eins zurückgesetzt (selbe Primzahl nochmal probiert)
		else
		{
			if (z < prime[i] || n < prime[i])															//Kurzer Abschnitt zur Codeeffizient, optional
			{
				break;
			}
		}
	}

	if ((double)z / (double)n > 1)																		//Ruft Unterprogramm "UnechterBruch" auf, wenn Zahl größer 1
	{
		UnechterBruch(z, n);
	}
	else
	{
		cout << "Als gekuerzter Bruch:\n" << z << "/" << n << endl;
	}

}

void UnechterBruch(int z, int n)																		//Unterfunktion UnechterBruch, nimmt Zähler und Nenner entgegen
{
	int a = 0;																							//Ganzzahl vor dem Bruch
	while (true)
	{
		z -= n;																							//Zieht den Nenner vom Zähler ab
		a++;																							//Rechnet 1 auf die Ganzzahl vor dem Bruch dazu
		if ((double)z / (double)n < 1)
			break;																						//Hört auf, wenn der Bruch nicht mehr unecht ist
	}

	cout << "Als gekuerzter Bruch:\n" << a << " " << z << "/" << n << endl;
}

